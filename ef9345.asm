;======================================================================
;	EF9345 DRIVER FOR ROMWBW
;
;	PARTS WRITTEN BY: ALAN COX
;	REVISED/ENHANCED BY LASZLO SZOLNOKI -- 01/2024
;======================================================================
; TODO:
;	- 40X24 IMPLEMENTATION
;======================================================================
; EF9345 DRIVER - CONSTANTS
;======================================================================
;
TERMENABLE		.SET	TRUE      ;TRUE		; INCLUDE TERMINAL PSEUDODEVICE DRIVER
;
EF9345_BASE	.EQU	$40
SETREG		.EQU	EF9345_BASE + 4
DATAACC		.EQU	EF9345_BASE + 5
EFRESET		.EQU	EF9345_BASE + 6
;
R0		.EQU	$20
R1		.EQU	R0+1
R2		.EQU	R0+2
R3		.EQU	R0+3
R4		.EQU	R0+4
R5		.EQU	R0+5
R6		.EQU	R0+6
R7		.EQU	R0+7
;
XA		.EQU	R5
YA		.EQU	R4
XP		.EQU	R7
YP		.EQU	R6
;
EXEC	.EQU	00001000b
;
TGSREG	 	.EQU 	1
MATREG		.EQU	2
PATREG		.EQU	3
DORREG		.EQU	4
RORREG		.EQU	7
;WRTINDIR	.EQU 10000000b
;
; CMD
;
NOP		.EQU	$91		;
IND		.EQU	$80		;
CLF		.EQU	$05		;
OCT		.EQU	$30		;
OCTAUX	.EQU	$04		; AUXILIARY POITER
KRF		.EQU	$00		; NO AUTOINCREMENT
KRL		.EQU	$50		; NO AUTOINCREMENT
INY		.EQU	$B0		; INC Y
;
;IND_TGS		.EQU	$81
;IND_MAT		.EQU	$82
;IND_PAT		.EQU	$83
;IND_DOR		.EQU	$84
;IND_ROR		.EQU	$87
RDREG	.EQU	00001000b
;WRREG	.EQU    ~RDREG
;
; | 1 | 0 | 0| 0| R/!W | r | r | r |   IND command
;                        0   0   1     TGS
;                        0   1   0     MAT
;                        0   1   1     PAT
;                        1   0   0     DOR
;                        1   0   1
;                        1   1   0
;                        1   1   1     ROR
;
FALSE		.EQU	0
TRUE		.EQU	~FALSE
BDOS		.EQU	5
;						MAT5	MAT4
; fixed complemented	  0		  0
; flash complemented	  1		  0
; fixed underlined		  0		  1
; flash underlined		  1		  1
;
EF9345_NOCU	.EQU	10111111B	; MAT6 = 0 : NO CURSOR
EF9345_BLK	.EQU	00100000B	; MAT5 = 1 : BLINK CURSOR
EF9345_NOBL	.EQU	11011111B	; MAT5 = 0 : NO BLINK
;
EF9345_BLOK	.EQU	11101111b	; MAT4 = 0 : BLOCK CURSOR
EF9345_ULIN	.EQU	00010000b	; MAT4 = 1 : UNDERLINE CURSOR
;
EF9345_CURENA	.EQU	TRUE			; ENABLE CURSOR
;
EF9345_MARCOL	.EQU	00000000B		; MARGIN COLOR BLACK : MAT0 = R, MAT1 = G, MAT2 = B
EF9345_MARENA	.EQU	00001000B		; MARGIN INSERT : MAT3 = 1
;
EF9345_CUREN	.EQU	01000000B	; MAT6 = 1 : CURSOR ENABLED
EF9345_DISCU	.EQU	10111111B	; MAT6 = 0 : NO CURSOR
;
EF9345_FLASH	.EQU	00100000B	; MAT5 = 1 : BLINK CURSOR
EF9345_NOFLASH	.EQU	11011111B	; MAT5 = 0 : NO BLINK
;
EF9345_COMPL	.EQU	11101111b	; MAT4 = 0 : BLOCK CURSOR
EF9345_ULIN		.EQU	00010000b	; MAT4 = 1 : UNDERLINE CURSOR
;
EF9345_FLASHCHAR	.EQU    00001000B
EF9345_REVERSCHAR	.EQU    10000000B
;
#IF EF9345_CURENA
EF9345_CSTY .SET EF9345_CUREN | EF9345_FLASH | EF9345_ULIN | EF9345_MARENA | EF9345_MARCOL
#ELSE
EF9345_CSTY .SET EF9345_MARENA | EF9345_MARCOL
#ENDIF
;
FIRSTLINE	.EQU	8
;
#IF (EF9345SIZE=V80X24)			; V80X24
DLINES		.EQU	24
DROWS		.EQU	80
DSCANL		.EQU	10
; ATTRIBUTES
EF_FLASH		.EQU	01000100B
EF_NEGATIVE		.EQU	10001000B
EF_UNDERLINE	.EQU	00100010B
EF_COLORSET		.EQU	00010001B
#ENDIF
;
#IF (EF9345SIZE=V40X24)
DLINES		.EQU	24
DROWS		.EQU	40
DSCANL		.EQU	10
; ATTRIBUTES
EF_FLASH		.EQU	01000100B
EF_NEGATIVE		.EQU	10001000B
EF_UNDERLINE	.EQU	00100010B
EF_COLORSET		.EQU	00010001B
#ENDIF
;
; DISTRICTS
;
DIST0 	.EQU 	0
DIST1 	.EQU 	$20
DIST2 	.EQU 	$80
DIST3 	.EQU 	$A0
;
BG_BLACK	.EQU	$0
BG_RED		.EQU	$10
BG_GREEN	.EQU	$20
BG_BROWN	.EQU	$30
BG_BLUE		.EQU	$40
BG_MAGENTA	.EQU	$50
BG_CYAN		.EQU	$60
BG_WHITE	.EQU	$70
FG_BLACK	.EQU	0
FG_RED		.EQU	1
FG_GREEN	.EQU	2
FG_BROWN	.EQU	3
FG_BLUE		.EQU	4
FG_MAGENTA	.EQU	5
FG_CYAN		.EQU	6
FG_WHITE	.EQU	7
;
SCREENSIZE	.EQU	DROWS * DLINES
;
;======================================================================
; VDU DRIVER - INITIALIZATION
;======================================================================
;
EF_INIT:
;
	LD IY,EF_IDAT			; POITER TO INSTANCE DATA
;
	CALL	NEWLINE			; FORMATTING
	PRTS("EF9345 : IO=0x$")
	LD	A,EF9345_BASE
	CALL	PRTHEXBYTE

	PRTS(" MODE=$")			; OUTPUT DISPLAY FORMAT
	LD	A,DROWS
	CALL	PRTDECB
	PRTS("X$")
	LD	A,DLINES
	CALL	PRTDECB

	CALL EF_PROBE		; CHECK FOR HW EXISTENCE
	JR	Z,EF_INIT1		; CONTINUE IF HW PRESENT
;
	PRTS(" NOT PRESENT$")
	XOR A
	OR	-8				; HARDWARE NOT PRESENT
	RET
;
EF_INIT1:
	OUT (EFRESET),A		; HARDWARE RESET
;
	LD A,DIST0
	LD (CON_BANKY),A		;
;
	CALL 	EF_CRTINIT			; INIT EF9345 CHIP
;
; ADD OURSELVES TO VDA DISPATCH TABLE
	LD	BC,EF_FNTBL		; BC := FUNCTION TABLE ADDRESS
 	LD	DE,EF_IDAT		; DE := VDU INSTANCE DATA PTR
	CALL VDA_ADDENT		; ADD ENTRY, A := UNIT ASSIGNED
;
#IF TERMENABLE
	; INITIALIZE EMULATION
	LD	C,A				; ASSIGNED VIDEO UNIT IN C
	LD	DE,EF_FNTBL		; DE := FUNCTION TABLE ADDRESS
	LD	HL,EF_IDAT		; HL := VDU INSTANCE DATA PTR
	CALL TERM_ATTACH	; DO IT
#ENDIF
;
	XOR	A			; SIGNAL SUCCESS
	RET
;
EF_CRTINIT:
	LD DE,(R0+EXEC)*256 + NOP	; FORCE NOP
	CALL EF_WWRREG
;
	LD HL,EF_INIT9345			; INITIAL SETUP PARAMETERS
	CALL EF_LOAD_MODE
;
	LD DE,0
	LD (VDA_OFFSET),DE
;
#IF (EF9345SIZE = V40X24)
	XOR A
	LD (VDATYPESET),A
#ENDIF
;
; E = CHARACTER ATTRIBUTES : E0 = BLINK, E1 = UNDELINE, E2 = REVERSE, E3  = COLOR SET
; VIDEO SET CHARACTER ATTRIBUTE FOR SCROLL, KRL, ETC.
	LD E,00000000B
	CALL EF_VDASAT
;
	LD E,BG_BLACK + FG_WHITE		; SET CHARACTER COLOR
	CALL EF_VDASCO
;
; VIDEO SET CURSOR STYLE
; ENTRY: C = VIDEO UNIT, D = START/END, E = STYLE : E0 = BLINK/FLASH, E1 = UNDELINE, E2 = REVERSE/COMPLEMENT
; MAT5 = 1 : FLASH, MAT4 = 0 : COMPLEMENT
; RETURN A = STATUS
	LD E,3						; UNDERLINED BLINKING
	CALL EF_VDASCS
;
	CALL EF_CLEARALL
;
	LD DE,0						; SET CURSOR TO 0,0
	CALL EF_VDASCP
	RET
;
EF_CLEARALL:
	LD DE,0			; SET CURSOR 0,0
	CALL EF_VDASCP	; D = ROW, E = COLUMNS
	LD HL, DROWS * DLINES
;
	LD E,' '
	CALL EF_VDAFIL
	XOR A
	RET
;
; R1 := C BYTE IS THE CHARACTER CODE
; R2 := B BYTE TYPE AND SET, OTHER PARAMETERS
; R3 := A BYTE ATTRIBUTES, NEGATIVE, FG COLOR, FLASH, BG COLOR
;
#IF (EF9345SIZE=V80X24)
EF_KRL80:
	PUSH DE
	LD DE,R0*256 + KRL		; R0 KRL COMMAND
	CALL EF_WWRREG
	LD D,R3
	LD A,(VDAATTR)			; DOUBLE ATTRIBUTES FOR LOWER NIBBLE
	LD E,A
	CALL EF_WWRREG
	POP DE
	RET
#ENDIF
;
#IF (EF9345SIZE = V40X24)
EF_KRF40:
	PUSH DE
	LD DE,R0*256 + KRF
	CALL EF_WWRREG
	LD D,R3
	LD A,(VDACOLOR)
	LD B,A
	LD A,(VDAATTR)
	OR B
	LD E,A			; COLOR
	CALL EF_WRREG
	LD D,R2				;
	LD A,(VDATYPESET)
	LD E,A
	CALL EF_WRREG
	POP DE
	XOR A
	RET
#ENDIF
;
;----------------------------------------------------------------------
; PROBE FOR EF9345 HARDWARE
;----------------------------------------------------------------------
;
; ON RETURN, ZF SET INDICATES HARDWARE FOUND
;
EF_PROBE:
	LD DE,R1*256+'a'
	LD H,E
	CALL EF_WRREG
	CALL EF_RDREG
	CP H
	RET
;
;----------------------------------------------------------------------
; WAIT FOR VDU TO BE READY FOR A DATA READ/WRITE
;----------------------------------------------------------------------
;
EF_WAITRDY:
	LD A,R0
	OUT (SETREG),A
	IN A,(DATAACC)
	RLA
	JR C,EF_WAITRDY
	RET
;
;----------------------------------------------------------------------
; UPDATE EF9345 REGISTERS
;   EF_WRREG WRITES VALUE IN E TO EF9345 REGISTER SPECIFIED IN D
;	EF_WWRREG AFTER WAITING FOR READY WRITES VALUE IN E TO EF9345 REGISTER SPECIFIED IN D
;----------------------------------------------------------------------
;
EF_WWRREG:
	CALL EF_WAITRDY
EF_WRREG:
	LD A,D
	OUT (SETREG),A
	LD A,E
	OUT (DATAACC),A
	RET
;
;----------------------------------------------------------------------
; READ EF9345 REGISTERS
;   EF_RDREG READS EF9345 REGISTER SPECIFIED IN D AND RETURNS VALUE IN A AND E
;----------------------------------------------------------------------
EF_RDREG:
	CALL EF_WAITRDY
	LD A,D
	OUT (SETREG),A
	IN A,(DATAACC)
	LD E,A
	RET
;
;----------------------------------------------------------------------
; READ INDIRECT EF9345 REGISTERS
;   EF_READ_INDIR READS EF9345 REGISTER SPECIFIED IN D AND RETURNS VALUE IN A AND E
;----------------------------------------------------------------------
;
EF_READ_INDIR:
	LD A,IND
	OR D
	OR RDREG
	LD E,A
	LD D,R0 + EXEC
	CALL EF_WWRREG
	LD D,R1
	CALL EF_RDREG
	RET
;
;----------------------------------------------------------------------
; WRITES INDIRECT EF9345 REGISTERS
;   EF_LOAD_INDIR WRITES VALUE IN E TO INDIRECT EF9345 REGISTER SPECIFIED IN D
;----------------------------------------------------------------------
;
EF_LOAD_INDIR:			; D = TARGET REGISTER, E = VALUE TO WRITE
	PUSH DE
	LD D,R1
	CALL EF_WWRREG
	POP DE
	PUSH DE
	LD A,IND
	OR D
	LD E,A
	LD D,R0 + EXEC
	CALL EF_WWRREG
	POP DE
	RET
;
EF_LOAD_MODE:			;	LOAD MODE
	LD D,TGSREG			; START INDIRECT REGISTER 1 : TGS
	LD B,INIT_CNT		; LOAD 5 INDIRECT REGISTERS
MODEREG:
	LD E,(HL)
	CALL EF_LOAD_INDIR
	INC HL
	INC D
	LD A,INIT_CNT
	CP D
	JR NZ,NOSKIP
	INC D
	INC D
	LD E,(HL)
	LD A,(CON_BANKY)
	ADD A,E
	LD E,A
	CALL EF_LOAD_INDIR
	RET
NOSKIP:
	DJNZ MODEREG
	RET
;
GETXY:				; D = ROW, E = COLUMNS
	CALL GETX
	CALL GETY
	RET
;
GETX:				; E = COLUMNS
	CALL EF_WAITRDY
	LD D,XP
	CALL EF_RDREG
#IF (EF9345SIZE=V80X24)
	RLCA			; CORRECTION 80 ROWS MODE
#ENDIF
	LD E,A
	RET
;
GETY:				; D = ROW
	CALL EF_WAITRDY
	PUSH DE
	LD D,YP
	CALL EF_RDREG
	AND 00011111B
	PUSH HL
	LD HL,(VDA_OFFSET)
	SUB H
	POP HL
	SUB FIRSTLINE
	POP DE
	LD D,A
	RET
;
EF_LOADFONTS:
	PRTS("Not implemented$")
	CALL NEWLINE
	SYSCHKERR(ERR_NOTIMPL)	; NOT IMPLEMENTED (YET)
	LD A,-2
	OR A
	RET
;
EF_NOTIMP:
	PRTS("Not implemented$")
	CALL NEWLINE
	SYSCHKERR(ERR_NOTIMPL)	; NOT IMPLEMENTED (YET)
	XOR A
	OR -2			; FUNCTION NOT IMPLEMENTED
	RET
;
EF_CURSORON:			; CURSOR DISPLAY ENABLE
	PUSH DE
	PUSH AF
	LD D,MATREG			; LOAD CURSOR ENABLE
	CALL EF_READ_INDIR
	OR 01000000B
	LD D,MATREG			; SET CURPOS ENABLE
	LD E,A
	CALL EF_LOAD_INDIR
	POP AF
	POP DE
	RET
;
EF_CURSOROFF:
	PUSH DE
	PUSH AF
	LD D,MATREG			; LOAD CURSOR ENABLE
	CALL EF_READ_INDIR
	AND 10111111B
	LD D,MATREG			; SET CURSOR ENABLE
	LD E,A
	CALL EF_LOAD_INDIR
	POP AF
	POP DE
	RET
;
INCCURSOR:				;CURSOR POSITION, D = ROW, E = COLUMN
; Y , X WITH MODULO DROWS
	PUSH DE
	PUSH HL
	LD HL,(VDA_OFFSET)
	LD DE,(VDA_POS)
	ADD HL,DE
	INC DE
	LD A,DROWS
	CP E
	JR NZ,CURS0
	LD E,0
	INC D
	LD A,DLINES
	CP D
	JR NZ,CURS0
;	LD D,0
	DEC D				; Y REMAINS INSIDE THE BOUNDARY
	LD (VDA_POS),DE
	CALL EF_VDASCP
	POP HL
	POP DE
	OR -6		; PARAMETER OUT OF RANGE
	RET
CURS0:
	LD (VDA_POS),DE
	CALL EF_VDASCP
	POP HL
	POP DE
	RET
;
;----------------------------------------------------------------------
;  DISPLAY CONTROLLER CHIP INITIALIZATION
;----------------------------------------------------------------------
;
EF_INIT9345:
#IF (EF9345SIZE=V80X24)			;E)
TGS:	.DB 11000010b		; 80 char/row, long char code (12 bits) : TGS Register interlaced
MAT:	.DB EF9345_CSTY			;01001000b		; cursor enabled, fixed complent cursor, margin color = black : MAT Register
PAT:	.DB 01111110b		; 80 char/row, long code, upper/lower bulk on, conceal on,
							; I high during active disp. area, status row disebled : PAT Register
DOR:	.DB 10001111b		; DOR(3:0) = 1111   : color c0 = white, DOR(7:4) = 1000 : color c1 = black
ROR:	.DB 00001000b		; ROR(7:5) =   000  : displayed page memory starts from block 0
							; ROR(4:0) = 01000 : origin row = 8
#ENDIF
;
#IF (EF9345SIZE=V40X24)
TGS:	.DB 00000000B		; 40 char/row, long char code (24 bits) : TGS Register interlaced
MAT:	.DB EF9345_CSTY		; 01001100B cursor enabled, fixed complent cursor, margin color = black : MAT Register
PAT:	.DB 01111110B		; 40 char/row, long code, upper/lower bulk on, conceal on,
							; I high during active disp. area, status row disebled : PAT Register
; DOR register initialization
;
; DOR(3:0) = 0011 : alpha UDS slices in block 3
; DOR(6:4) = 001 : semigraphic uds slices in block 2 and 3
; DOR 7 = 0 : Quadrichrome slices from block 0
DOR:	.DB 0		;
ROR:	.DB 00001000B		; ROR(7:5) =   000  : displayed page memory starts from block 0
							; ROR(4:0) = 01000 : origin row = 8
#ENDIF

INIT_CNT:	.EQU	$ - EF_INIT9345
;
;======================================================================
; EF9345 DRIVER - VIDEO DISPLAY ADAPTER FUNCTIONS
;======================================================================
;
;VDA_FNCNT		.EQU	16
EF_FNTBL:
	.DW	EF_VDAINI
	.DW	EF_VDAQRY
	.DW	EF_VDARES
	.DW	EF_VDADEV
	.DW	EF_VDASCS
	.DW	EF_VDASCP
	.DW	EF_VDASAT
	.DW	EF_VDASCO
	.DW	EF_VDAWRC
	.DW	EF_VDAFIL
	.DW	EF_VDACPY
	.DW	EF_VDASCR
	.DW	EF_NOTIMP		;PPK_STAT
	.DW	EF_NOTIMP		;PPK_FLUSH
	.DW	EF_NOTIMP		;PPK_READ
	.DW	EF_VDARDC
#IF (($ - EF_FNTBL) != (VDA_FNCNT * 2))
	.ECHO	"*** INVALID VDU FUNCTION TABLE ***\n"
#ENDIF
;
EF_VDAINI:
; VIDEO INITIALIZE
; FULL REINITIALIZATION, CLEAR SCREEN, CURRENTLY IGNORES VIDEO MODE AND BITMAP DATA
	PUSH HL
	CALL EF_INIT1
	POP HL
	LD A,L
	OR H
	CALL NZ,EF_LOADFONTS
	XOR	A
	RET
;
EF_VDAQRY:
; VIDEO QUERY
; ENTRY: C = VIDEO UNIT, HL = FONT BITMAT
; RETURN: C = VIDEO MODE, D = ROWS, E = COLUMNS, HL = FONT BITMAT
	LD	C,$00					; MODE ZERO IS ALL WE KNOW
	LD	D,DLINES
	LD	E,DROWS
	LD	HL,0					; EXTRACTION OF CURRENT BITMAP DATA NOT SUPPORTED
	XOR	A						; SIGNAL SUCCESS
	RET
;
EF_VDARES:
; VIDEO RESET
; SOFT RESET, CLEAR SCREEN, HOME CURSOR, RESTORE ATTRIBUTE/COLOR DEFAULTS
;
	CALL EF_CLEARALL
	CALL EF_LOADCSTYLE
	LD	DE,0
	LD (VDA_OFFSET),DE
	CALL EF_VDASCP
	XOR A
	RET
;
EF_VDADEV:
; VIDEO DEVICE
; ENTRY: C = VIDEO UNIT
; RETURN: D := DEVICE TYPE, E := DEVICE NUMBER, H := DEVICE UNIT MODE, L := DEVICE I/O BASE ADDRESS
	LD	DE,(VDADEV_EF9345 * 256) + 0	; D := DEVICE TYPE
										; E := PHYSICAL UNIT IS ALWAYS ZERO
	LD HL,EF9345_BASE					; H INDICATES THE VARIANT OF THE CHIP OR CIRCUIT, H = 0 : NO VARIANTS
										; L := BASE I/O ADDRESS
	XOR	A								; SIGNAL SUCCESS
	RET
;
EF_VDASCS:
; VIDEO SET CURSOR STYLE
; ENTRY: C = VIDEO UNIT, D = START/END, E = STYLE : E0 = BLINK/FLASH, E1 = UNDELINE, E2 = REVERSE/COMPLEMENT
; MAT5 = 1 : FLASH, MAT4 = 0 : COMPLEMENT
; RETURN A = STATUS
	XOR A
	SRA E
	JR NC,VDASCS0
	OR EF9345_FLASH		; CURSOR IS BLINKING
VDASCS0:
	SRA E
	JR NC,VDASCS1
	OR EF9345_ULIN		; UNDERLINED CURSOR
	JR VDASCS2
VDASCS1:
	SRA E
	JR NC,VDASCS2
	AND EF9345_COMPL
VDASCS2:
	LD (VDACATTR),A
	CALL EF_LOADCSTYLE
	XOR A
	RET
;
EF_VDASCP:
; SET VIDEO CURSOR POSITION
; ENTRY: C = VIDEO UNIT, D = ROW, E = COLUMN
; RETURN A = STATUS
; CHECKING THE FEASIBILITY OF THE INPUT VALUES
	LD A,DLINES-1
	CP D
	JR C,VDASCP0
	LD A,DROWS-1
	CP E
	JR C,VDASCP0
	LD (VDA_POS),DE		; D = ROW, E = COLUMNS
;
	PUSH DE
#IF (EF9345SIZE=V80X24)
	RRC E				; ADJUST TO 80 COLUMN LAYOUT
#ENDIF
	LD D,XP				; X POSITION
	CALL EF_WWRREG
	POP DE
;
	PUSH HL
	LD HL,(VDA_OFFSET)
	LD A,H
	POP HL
;
	ADD A,FIRSTLINE
	ADD A,D
	CP FIRSTLINE+DLINES
	JR C,SETYP0
	SUB DLINES
SETYP0:
	LD E,A
	LD A,(CON_BANKY)		; STAY IN DISTRICT
	OR E
	LD E,A
	LD D,YP
	CALL EF_WWRREG
	XOR	A
	RET
VDASCP0:
	XOR A
	OR -6			; PARAMETERS OUT OF RANGE $FF
	RET
;
EF_VDASAT:
; VIDEO SET CHARACTER ATTRIBUTE FOR SCROLL, KRL, ETC.
; ENTRY: C = VIDEO UNIT, E = ATTRIBUTE
; 80 CHARACTER/ROW STYLE := E0 = BLINK, E1 = UNDELINE, E2 = REVERSE, E3 = COLOR SELECT
; 40 CHARACTER/ROW STYLE := E0 = BLINK, E1 = UNDELINE, E2 = REVERSE, E3 = COLOR SELECT, E4..E7 = TYPE AND SET
; B(0)		:= INSERT
; B(1)		:= DOUBLE HIGHT
; B(2)		:= concealed character appears as a space on the screen
; B(3)		:= DOUBLE WIDTH
; B(4..7) 	:= TYPE AND SET
; RETURN A = STATUS
#IF (EF9345SIZE=V80X24)
	XOR A
	SRA E				; IS BLINKING
	JR NC,VDASAT0
	OR EF_FLASH
VDASAT0:
	SRA E
	JR NC,VDASAT1
	OR EF_UNDERLINE		; UNDERLINED CURSOR
VDASAT1:
	SRA E
	JR NC,VDASAT2
	OR EF_NEGATIVE		; NEGATIVE CURSOR
VDASAT2:
	SRA E
	JR NC,VDASAT3
	OR EF_COLORSET
VDASAT3:
#ENDIF
#IF (EF9345SIZE=V40X24)
; set VDATYPESET
	LD A,E
	AND $F0
	LD (VDATYPESET),A
	XOR A
	SRA E				; IS BLINKING
	JR NC,VDASAT0
	OR EF9345_FLASHCHAR
VDASAT0:
	SRA E
	SRA E
	JR NC,VDASAT1
	OR EF9345_REVERSCHAR
VDASAT1:
#ENDIF
	LD (VDAATTR),A
	XOR A
	RET
;
EF_LOADCSTYLE:
	LD A,(VDACATTR)
	LD B,A
	LD D,MATREG
	CALL EF_READ_INDIR
	AND 11001111B
	OR B
	LD E,A
	LD D,MATREG
	CALL EF_LOAD_INDIR
	RET
;
EF_VDASCO:
; VIDEO SET CHARACTER COLOR
; ENTRY C = VIDEO UNIT, E = COLOR
; RETURN A = STATUS
	CALL EF_WAITRDY
#IF (EF9345SIZE=V80X24)	; COLOR SETUP USE MARGIN COLOR IN MAT AND
	LD A,E
	LD B,A			; B = BG
	SRL B
	SRL B
	SRL B
	SRL B
	AND $F8			; MASK BG COLOR
	LD A,E
	AND $07			; MASK FG COLOR
	LD C,A			; C = FG
	LD D,DORREG		; LOAD FG COLOR FROM DOR(3..0)
	CALL EF_READ_INDIR
	AND $F8
	OR C			; SET NEW FG COLOR
	LD E,A
	LD D,DORREG		; LOAD NEW FG COLOR
	CALL EF_LOAD_INDIR
;
	LD D,MATREG		; LOAD BG COLOR
	CALL EF_READ_INDIR
	AND $F8			; MASK BG COLOR
	OR B			; SET NEW BG COLOR
	LD E,A
	LD D,MATREG		; LOAD NEW BG COLOR
	CALL EF_LOAD_INDIR
#ENDIF
#IF (EF9345SIZE=V40X24)
	LD HL,VDACOLOR
	LD A,E
	AND $7			; MASK FG COLOR
	RLD
	LD A,E
	SRL A			; BG COLOR TO LOW ORDER FOUR BITS
	SRL A
	SRL A
	SRL A
	RLD
#ENDIF
	XOR A
	RET
;
EF_VDAWRC:
; VIDEO WRITE CHARACTER,
; ENTRY C = VIDEO UNIT, E = CHARACTER
; RETURN A = STATUS
#IF (EF9345SIZE=V80X24)
	CALL EF_KRL80
	LD D,R1+EXEC
	CALL EF_WWRREG
#ENDIF
#IF (EF9345SIZE=V40X24)
	CALL EF_KRF40
	LD D,R1+EXEC
	CALL EF_WWRREG
#ENDIF
	CALL INCCURSOR
	XOR A
	RET
;
EF_VDAFIL:
; VIDEO FILL
; ENTRY: C = VIDEO UNIT, E = CHARACTER, HL = COUNT OF CHARACTERS
; RETURN A = STATUS
	CALL EF_CURSOROFF
VDAFIL0:
	CALL EF_VDAWRC
	DEC HL
	LD A,H
	OR L
	JR NZ,VDAFIL0
	CALL EF_CURSORON
	XOR A
	RET
;
EF_VDACPY:
; VIDEO COPY
; ENTRY C = VIDEO UNIT, D = SOURCE ROW, E =  SOURCE COLUMN, L = COUNT
; RETURN A = STATUS
	PUSH DE			; SAVE SOURCE
	LD A,L
	LD (CPYCNT),A
	CALL EF_CURSOROFF
	CALL GETXY		; GET AND SAVE CURRENT CURSOR POSITION
	LD (CURPOS),DE
; CHECK END OF SCREEN
	LD H,D			; D = CURRENT LINE
	LD E,DROWS		; CHARACTERS IN ROW
	CALL MULT8		; LINES * DROWS
	POP DE
	PUSH DE
	LD D,0
	ADD HL,DE		; ADD CHARACTERS IN CURRENT LINE := USED CHARACTERS
	EX DE,HL
	LD HL,DLINES*DROWS	; AVAILABLE CHARACTER COUNT
	XOR A
	SBC HL,DE		; REMAINING CHARACTERS = AVAILABLE - USED
	LD C,L			; SAVE REMAINING CHARACTER COUNT
	LD A,(CPYCNT)
	LD B,A
	LD E,A
	LD D,0
	SBC HL,DE		; COMPARE COPY COUNT WITH AVAILABLE
	JR NC,CPY0
	LD B,C			; ADJUST COPY COUNT
CPY0:
	POP DE
	CALL EF_VDASCP	; SET SOURCE AS CURSOR
	LD HL,EF_BUF
	PUSH BC
CPYRD:
#IF (EF9345SIZE=V80X24)
	PUSH BC
	CALL EF_VDARDC
	POP BC
	LD (HL),E
	INC HL
#ENDIF
#IF (EF9345SIZE=V40X24)
	PUSH HL
	PUSH BC
	CALL EF_VDARDC
	LD A,L
	POP BC
	POP HL
	LD (HL),E
	INC HL
	LD (HL),A
	INC HL
#ENDIF
	CALL INCCURSOR
	DJNZ CPYRD
	LD DE,(CURPOS)	; RECOVER AND SET CURSOR POSITION
	CALL EF_VDASCP
	POP BC
	LD HL,EF_BUF
CPYWR:
#IF (EF9345SIZE=V80X24)
	PUSH BC
	LD E,(HL)
	CALL EF_VDAWRC
	INC HL
	POP BC
	DJNZ CPYWR
#ENDIF
#IF (EF9345SIZE=V40X24)
	PUSH BC
	LD E,(HL)
	INC HL
	PUSH HL
	LD L,(HL)
	CALL EF_VDAWRC
	POP HL
	INC HL
	POP BC
	DJNZ CPYWR
#ENDIF
	; RESTORE CURSOR
	LD DE,(CURPOS)
	CALL EF_VDASCP
	CALL EF_CURSORON
	XOR A
	RET
;
EF_VDASCR:
; VIDEO SCROLL
; ENTRY: C = VIDEO UNIT, E = LINES
; RETURN A = STATUS
	CALL EF_CURSOROFF
VDASCR0:
	LD A,E
	OR A
	JR Z,VDASCR2		; SCROLL 0, NOTHING TO DO
	PUSH DE
	RLCA
	JR C,VDASCR1
	CALL EF_SCRUP
	POP DE
	DEC E
	JR VDASCR0
VDASCR1:
	CALL EF_SCRDOWN
	POP DE
	INC E
	JP VDASCR0
VDASCR2:
	CALL EF_CURSORON
	RET
;
EF_SCRUP:
	LD HL,(VDA_OFFSET)
	LD DE,$0100 			; inc y
	ADD HL,DE
	LD A,H
	CP DLINES
	JR NZ,SCRUP0
	LD HL,0
SCRUP0:
	LD (VDA_OFFSET),HL
	LD A,(CON_BANKY)
	ADD A,H
	ADD A,FIRSTLINE
	LD E,A
	LD D,RORREG
	CALL EF_LOAD_INDIR
; fill exposed line
	LD HL,(VDA_POS)
	PUSH HL
	LD HL,(DLINES-1)*256
	EX DE,HL
SCRCLEAR:
	CALL EF_VDASCP
	LD E,' '
	LD HL,DROWS
	CALL EF_VDAFIL
;
	POP HL
	EX DE,HL
	CALL EF_VDASCP
	RET
;
EF_SCRDOWN:
	XOR A
	LD HL,(VDA_OFFSET)
	LD DE,$FF00
	ADD HL,DE
	LD A,$FF
	CP H
	JR NZ,SCRDOWN0
	LD H,DLINES-1
SCRDOWN0:
	LD (VDA_OFFSET),HL
	LD A,(CON_BANKY)
	ADD A,FIRSTLINE
	ADD A,H
	LD E,A
	LD D,RORREG
	CALL EF_LOAD_INDIR
; fill exposed line
	LD HL,(VDA_POS)
	PUSH HL
	LD DE,0
;	JR SCRCLEAR
	CALL EF_VDASCP
	LD E,' '
	LD HL,DROWS
	CALL EF_VDAFIL
;
	POP HL
	EX DE,HL
	CALL EF_VDASCP
	RET

;
EF_VDARDC:
; READ CHARACTER AT CURRENT VIDEO POSITION
; ENTRY: C = VIDEO UNIT
; RETURN: A = STATUS, E = CHARACTER, B = CHARACTER COLOR, C = CHARACTER ATTRIBUTES, L = CHARACTER TYPESET, 40X24 ONLY
#IF (EF9345SIZE = V80X24)
	LD D,R0
	LD A,KRL			; R0 KRL COMMAND NO AUTOINC
	OR RDREG
	LD E,A
	CALL EF_WWRREG
	LD D,R3 + EXEC		; READ ATTRIBUTES
	CALL EF_RDREG
	LD C,A
	CALL EF_WAITRDY
	LD D,R1+EXEC
	CALL EF_RDREG
	PUSH DE
; READ COLOR
	LD D,DORREG			; LOAD FG COLOR
	CALL EF_READ_INDIR
	AND $07
	LD B,A
	LD D,MATREG			; LOAD BG COLOR
	CALL EF_READ_INDIR
	RLCA
	RLCA
	RLCA
	RLCA
	AND $70
	OR B
	LD B,A
	POP DE
	XOR A
;	LD L,A
	RET
#ENDIF
#IF (EF9345SIZE = V40X24)
	LD D,R0
	LD A,KRF			; R0 KRL COMMAND NO AUTOINC
	OR RDREG
	LD E,A
	CALL EF_WWRREG
	LD D,R3 + EXEC		; READ CHARACTER ATTRIBUTES
	CALL EF_RDREG
	AND $77
	LD B,A
	RLC B
	RLC B
	RLC B
	RLC B
	LD A,E
	AND $88
	LD C,A
	LD D,R2 + EXEC		; READ CHARACTER TYPESET
	CALL EF_RDREG
	LD L,A
	LD D,R1+EXEC		; READ CHARACTER
	CALL EF_RDREG
	XOR A
	RET
#ENDIF
;
EF_IDAT:
	.DB	KBDMODE_NONE	; PS/2 8242 KEYBOARD CONTROLLER
	.DB	0
	.DB	0
;
VDA_POS:		.DW 0
CURPOS:			.DW 0
CPYCNT:			.DB 0
VDA_OFFSET:		.DW 0
CON_BANKY:		.DB 0
VDAATTR:		.DB 0	; CHARACTER ATTRIBUTES
VDACATTR:		.DB 0	; CURSOR ATTRIBUTES
VDACOLOR:		.DB 0	; CHARACTER COLOR
#IF (EF9345SIZE = V40X24)
VDATYPESET:		.DB 0	; 40 CHAR/ROW PARAMETER
#ENDIF
EF_BUF:
#IF (EF9345SIZE = V80X24)
	.FILL	DLINES*DROWS		;256,0	; COPY BUFFER
#ENDIF
#IF (EF9345SIZE = V40X24)
	.FILL 2*DLINES*DROWS		;512,0
#ENDIF
